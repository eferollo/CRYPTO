from Crypto.Util.number import long_to_bytes

def iroot(k, n):
    u, s = n, n+1
    while u < s:
        s = u
        t = (k-1) * s + n // pow(s, k-1)
        u = t // k
    return s

n = 131351460044200870397043709090757073761162762710937783517733229107904226870966872745226745597696586548174302909582621103277183989288690050168361125818537361050872346229066622594101064234388603274755138176619643103165293449739140148080737896335730451554731864570044670441823882004762340700839041015684123014453
e = 3
ct = 37530210357019911587955465192505553789667514311991143009308327842954099996986270301158530956679000756233105064992637131321365373293025939760146736501010384417433205180191397212404098036796136641805753972981010485392857194839921309525986679386609460462267249420186981

# Low exponent strategy (same as the RSA-Level-8)
# I have the modulo and the ciphertext. Since the exponent is too low (3),
# then the message is the integer cubic root of the ciphertext ct (the message is small -> m*m*m < n)
res = iroot(e, ct)
print(long_to_bytes(res).decode())
